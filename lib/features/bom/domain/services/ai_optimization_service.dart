import 'dart:math';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:logger/logger.dart';

import '../../../inventory/domain/repositories/inventory_repository.dart';
import '../../../suppliers/domain/repositories/supplier_repository.dart';
import '../entities/bill_of_materials.dart';
import '../repositories/bom_repository.dart';
import '../../presentation/providers/bom_providers.dart';
import '../../../inventory/domain/providers/inventory_repository_provider.dart'
    as inventory_provider;
import '../../../suppliers/presentation/providers/supplier_provider.dart'
    as supplier_provider;

/// AI-generated recommendation for BOM optimization
class AiRecommendation {
  const AiRecommendation({
    required this.id,
    required this.bomId,
    required this.type,
    required this.title,
    required this.description,
    required this.confidenceScore,
    required this.expectedImpact,
    required this.implementationComplexity,
    required this.estimatedSavings,
    required this.riskLevel,
    required this.priority,
    required this.category,
    required this.generatedAt,
    this.actionSteps = const [],
    this.affectedMaterials = const [],
    this.prerequisites = const [],
    this.metrics = const {},
  });

  final String id;
  final String bomId;
  final String type;
  final String title;
  final String description;
  final double confidenceScore; // 0.0 to 1.0
  final double expectedImpact; // Percentage improvement
  final String implementationComplexity; // Low, Medium, High
  final double estimatedSavings; // Dollar amount
  final String riskLevel; // Low, Medium, High
  final String priority; // Critical, High, Medium, Low
  final String category; // Cost, Quality, Efficiency, Sustainability
  final DateTime generatedAt;
  final List<String> actionSteps;
  final List<String> affectedMaterials;
  final List<String> prerequisites;
  final Map<String, dynamic> metrics;

  /// Get recommendation score for prioritization
  double get recommendationScore {
    final confidenceWeight = 0.3;
    final impactWeight = 0.4;
    final complexityWeight = 0.2;
    final riskWeight = 0.1;

    final complexityScore = _getComplexityScore();
    final riskScore = _getRiskScore();

    return (confidenceScore * confidenceWeight) +
        (expectedImpact / 100 * impactWeight) +
        (complexityScore * complexityWeight) +
        (riskScore * riskWeight);
  }

  double _getComplexityScore() {
    switch (implementationComplexity.toLowerCase()) {
      case 'low':
        return 1.0;
      case 'medium':
        return 0.6;
      case 'high':
        return 0.3;
      default:
        return 0.5;
    }
  }

  double _getRiskScore() {
    switch (riskLevel.toLowerCase()) {
      case 'low':
        return 1.0;
      case 'medium':
        return 0.7;
      case 'high':
        return 0.4;
      default:
        return 0.5;
    }
  }
}

/// Predictive insights generated by AI analysis
class PredictiveInsights {
  const PredictiveInsights({
    required this.bomId,
    required this.forecastHorizon,
    required this.demandForecast,
    required this.costTrends,
    required this.qualityPredictions,
    required this.supplierRiskAssessment,
    required this.materialAvailabilityForecast,
    required this.optimizationOpportunities,
    required this.generatedAt,
    this.confidenceIntervals = const {},
    this.scenarioAnalysis = const {},
  });

  final String bomId;
  final int forecastHorizon; // Days
  final Map<String, double> demandForecast; // Material ID -> Predicted demand
  final Map<String, List<double>> costTrends; // Material ID -> Cost trend
  final Map<String, double> qualityPredictions; // Material ID -> Quality score
  final Map<String, double> supplierRiskAssessment; // Supplier ID -> Risk score
  final Map<String, double>
      materialAvailabilityForecast; // Material ID -> Availability %
  final List<String> optimizationOpportunities;
  final DateTime generatedAt;
  final Map<String, Map<String, double>> confidenceIntervals;
  final Map<String, dynamic> scenarioAnalysis;

  /// Get overall forecast confidence
  double get overallConfidence {
    if (confidenceIntervals.isEmpty) return 0.8; // Default confidence

    final confidenceValues = confidenceIntervals.values
        .expand((interval) => interval.values)
        .toList();

    if (confidenceValues.isEmpty) return 0.8;

    return confidenceValues.reduce((a, b) => a + b) / confidenceValues.length;
  }

  /// Get high-risk materials
  List<String> get highRiskMaterials {
    return materialAvailabilityForecast.entries
        .where((entry) => entry.value < 0.7)
        .map((entry) => entry.key)
        .toList();
  }
}

/// Optimization suggestions with detailed analysis
class OptimizationSuggestions {
  const OptimizationSuggestions({
    required this.bomId,
    required this.overallScore,
    required this.costOptimizations,
    required this.qualityImprovements,
    required this.efficiencyEnhancements,
    required this.sustainabilityOptions,
    required this.riskMitigations,
    required this.generatedAt,
    this.implementationRoadmap = const [],
    this.expectedOutcomes = const {},
  });

  final String bomId;
  final double overallScore; // 0.0 to 100.0
  final List<AiRecommendation> costOptimizations;
  final List<AiRecommendation> qualityImprovements;
  final List<AiRecommendation> efficiencyEnhancements;
  final List<AiRecommendation> sustainabilityOptions;
  final List<AiRecommendation> riskMitigations;
  final DateTime generatedAt;
  final List<String> implementationRoadmap;
  final Map<String, double> expectedOutcomes;

  /// Get all recommendations sorted by priority
  List<AiRecommendation> get allRecommendations {
    final all = [
      ...costOptimizations,
      ...qualityImprovements,
      ...efficiencyEnhancements,
      ...sustainabilityOptions,
      ...riskMitigations,
    ];

    all.sort((a, b) => b.recommendationScore.compareTo(a.recommendationScore));
    return all;
  }

  /// Get top priority recommendations
  List<AiRecommendation> get topRecommendations {
    return allRecommendations.take(5).toList();
  }

  /// Calculate total potential savings
  double get totalPotentialSavings {
    return allRecommendations
        .map((rec) => rec.estimatedSavings)
        .fold(0.0, (sum, savings) => sum + savings);
  }
}

/// AI Optimization Service - Machine learning and AI-driven BOM optimization
class AiOptimizationService {
  AiOptimizationService({
    required this.bomRepository,
    required this.inventoryRepository,
    required this.supplierRepository,
    required this.logger,
  });

  final BomRepository bomRepository;
  final InventoryRepository inventoryRepository;
  final SupplierRepository supplierRepository;
  final Logger logger;

  /// Generate AI-powered recommendations for BOM optimization
  Future<List<AiRecommendation>> generateAiRecommendations(String bomId) async {
    try {
      logger.i('Generating AI recommendations for BOM: $bomId');

      final bom = await bomRepository.getBomById(bomId);
      if (bom == null) {
        throw Exception('BOM not found: $bomId');
      }

      final recommendations = <AiRecommendation>[];

      // Cost optimization recommendations
      recommendations.addAll(await _generateCostOptimizations(bom));

      // Quality improvement recommendations
      recommendations.addAll(await _generateQualityImprovements(bom));

      // Efficiency enhancement recommendations
      recommendations.addAll(await _generateEfficiencyEnhancements(bom));

      // Sustainability recommendations
      recommendations.addAll(await _generateSustainabilityOptions(bom));

      // Risk mitigation recommendations
      recommendations.addAll(await _generateRiskMitigations(bom));

      // Sort by recommendation score
      recommendations.sort(
          (a, b) => b.recommendationScore.compareTo(a.recommendationScore));

      logger.i(
          'Generated ${recommendations.length} AI recommendations for BOM: $bomId');
      return recommendations;
    } catch (e, stackTrace) {
      logger.e('Error generating AI recommendations',
          error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Get predictive insights using machine learning models
  Future<PredictiveInsights> getPredictiveInsights(String bomId) async {
    try {
      logger.i('Generating predictive insights for BOM: $bomId');

      final bom = await bomRepository.getBomById(bomId);
      if (bom == null) {
        throw Exception('BOM not found: $bomId');
      }

      // Simulate ML model predictions
      final demandForecast = await _predictDemand(bom);
      final costTrends = await _predictCostTrends(bom);
      final qualityPredictions = await _predictQuality(bom);
      final supplierRiskAssessment = await _assessSupplierRisk(bom);
      final materialAvailabilityForecast =
          await _predictMaterialAvailability(bom);
      final optimizationOpportunities =
          await _identifyOptimizationOpportunities(bom);

      final insights = PredictiveInsights(
        bomId: bomId,
        forecastHorizon: 90, // 90 days forecast
        demandForecast: demandForecast,
        costTrends: costTrends,
        qualityPredictions: qualityPredictions,
        supplierRiskAssessment: supplierRiskAssessment,
        materialAvailabilityForecast: materialAvailabilityForecast,
        optimizationOpportunities: optimizationOpportunities,
        generatedAt: DateTime.now(),
        confidenceIntervals: _generateConfidenceIntervals(bom),
        scenarioAnalysis: await _performScenarioAnalysis(bom),
      );

      logger.i('Predictive insights generated for BOM: $bomId');
      return insights;
    } catch (e, stackTrace) {
      logger.e('Error generating predictive insights',
          error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  /// Get comprehensive optimization suggestions
  Future<OptimizationSuggestions> getOptimizationSuggestions(
      {String? bomId}) async {
    try {
      logger.i(
          'Generating optimization suggestions${bomId != null ? ' for BOM: $bomId' : ' for all BOMs'}');

      List<BillOfMaterials> boms;
      if (bomId != null) {
        final bom = await bomRepository.getBomById(bomId);
        if (bom == null) {
          throw Exception('BOM not found: $bomId');
        }
        boms = [bom];
      } else {
        boms = await bomRepository.getAllBoms();
      }

      final allCostOptimizations = <AiRecommendation>[];
      final allQualityImprovements = <AiRecommendation>[];
      final allEfficiencyEnhancements = <AiRecommendation>[];
      final allSustainabilityOptions = <AiRecommendation>[];
      final allRiskMitigations = <AiRecommendation>[];

      for (final bom in boms) {
        allCostOptimizations.addAll(await _generateCostOptimizations(bom));
        allQualityImprovements.addAll(await _generateQualityImprovements(bom));
        allEfficiencyEnhancements
            .addAll(await _generateEfficiencyEnhancements(bom));
        allSustainabilityOptions
            .addAll(await _generateSustainabilityOptions(bom));
        allRiskMitigations.addAll(await _generateRiskMitigations(bom));
      }

      // Calculate overall optimization score
      final overallScore = _calculateOverallOptimizationScore(boms);

      // Generate implementation roadmap
      final roadmap = _generateImplementationRoadmap([
        ...allCostOptimizations,
        ...allQualityImprovements,
        ...allEfficiencyEnhancements,
        ...allSustainabilityOptions,
        ...allRiskMitigations,
      ]);

      // Calculate expected outcomes
      final expectedOutcomes = _calculateExpectedOutcomes([
        ...allCostOptimizations,
        ...allQualityImprovements,
        ...allEfficiencyEnhancements,
        ...allSustainabilityOptions,
        ...allRiskMitigations,
      ]);

      final suggestions = OptimizationSuggestions(
        bomId: bomId ?? 'all',
        overallScore: overallScore,
        costOptimizations: allCostOptimizations,
        qualityImprovements: allQualityImprovements,
        efficiencyEnhancements: allEfficiencyEnhancements,
        sustainabilityOptions: allSustainabilityOptions,
        riskMitigations: allRiskMitigations,
        generatedAt: DateTime.now(),
        implementationRoadmap: roadmap,
        expectedOutcomes: expectedOutcomes,
      );

      logger.i('Optimization suggestions generated successfully');
      return suggestions;
    } catch (e, stackTrace) {
      logger.e('Error generating optimization suggestions',
          error: e, stackTrace: stackTrace);
      rethrow;
    }
  }

  // Private helper methods for AI analysis

  Future<List<AiRecommendation>> _generateCostOptimizations(
      BillOfMaterials bom) async {
    final recommendations = <AiRecommendation>[];

    // Bulk purchasing optimization
    if (bom.items.length > 10) {
      recommendations.add(AiRecommendation(
        id: 'bulk_purchase_${bom.id}_${DateTime.now().millisecondsSinceEpoch}',
        bomId: bom.id,
        type: 'bulk_purchasing',
        title: 'Bulk Purchasing Optimization',
        description:
            'Consolidate material orders to achieve bulk pricing discounts',
        confidenceScore: 0.85,
        expectedImpact: 12.0,
        implementationComplexity: 'Medium',
        estimatedSavings: bom.totalCost * 0.12,
        riskLevel: 'Low',
        priority: 'High',
        category: 'Cost',
        generatedAt: DateTime.now(),
        actionSteps: [
          'Analyze material consumption patterns',
          'Negotiate bulk pricing with suppliers',
          'Implement consolidated ordering system',
        ],
        affectedMaterials: bom.items.map((item) => item.itemId).toList(),
      ));
    }

    // Supplier consolidation
    final uniqueSuppliers = bom.items
        .where((item) => item.supplierCode != null)
        .map((item) => item.supplierCode!)
        .toSet();

    if (uniqueSuppliers.length > 5) {
      recommendations.add(AiRecommendation(
        id: 'supplier_consolidation_${bom.id}_${DateTime.now().millisecondsSinceEpoch}',
        bomId: bom.id,
        type: 'supplier_consolidation',
        title: 'Supplier Consolidation',
        description:
            'Reduce number of suppliers to improve negotiating power and reduce costs',
        confidenceScore: 0.78,
        expectedImpact: 8.0,
        implementationComplexity: 'High',
        estimatedSavings: bom.totalCost * 0.08,
        riskLevel: 'Medium',
        priority: 'Medium',
        category: 'Cost',
        generatedAt: DateTime.now(),
        actionSteps: [
          'Evaluate supplier capabilities',
          'Identify consolidation opportunities',
          'Negotiate new contracts',
        ],
        affectedMaterials: bom.items
            .where((item) => item.supplierCode != null)
            .map((item) => item.itemId)
            .toList(),
      ));
    }

    return recommendations;
  }

  Future<List<AiRecommendation>> _generateQualityImprovements(
      BillOfMaterials bom) async {
    final recommendations = <AiRecommendation>[];

    // Quality control enhancement
    recommendations.add(AiRecommendation(
      id: 'quality_control_${bom.id}_${DateTime.now().millisecondsSinceEpoch}',
      bomId: bom.id,
      type: 'quality_control',
      title: 'Enhanced Quality Control',
      description:
          'Implement advanced quality control measures to reduce defects',
      confidenceScore: 0.82,
      expectedImpact: 15.0,
      implementationComplexity: 'Medium',
      estimatedSavings: bom.totalCost * 0.05, // Savings from reduced waste
      riskLevel: 'Low',
      priority: 'High',
      category: 'Quality',
      generatedAt: DateTime.now(),
      actionSteps: [
        'Implement incoming inspection protocols',
        'Set up in-process quality monitoring',
        'Establish supplier quality agreements',
      ],
      affectedMaterials: bom.items.map((item) => item.itemId).toList(),
    ));

    return recommendations;
  }

  Future<List<AiRecommendation>> _generateEfficiencyEnhancements(
      BillOfMaterials bom) async {
    final recommendations = <AiRecommendation>[];

    // Process optimization
    recommendations.add(AiRecommendation(
      id: 'process_optimization_${bom.id}_${DateTime.now().millisecondsSinceEpoch}',
      bomId: bom.id,
      type: 'process_optimization',
      title: 'Production Process Optimization',
      description:
          'Optimize production processes to reduce waste and improve efficiency',
      confidenceScore: 0.75,
      expectedImpact: 10.0,
      implementationComplexity: 'Medium',
      estimatedSavings: bom.totalCost * 0.10,
      riskLevel: 'Medium',
      priority: 'Medium',
      category: 'Efficiency',
      generatedAt: DateTime.now(),
      actionSteps: [
        'Analyze current production processes',
        'Identify bottlenecks and inefficiencies',
        'Implement process improvements',
      ],
      affectedMaterials: bom.items.map((item) => item.itemId).toList(),
    ));

    return recommendations;
  }

  Future<List<AiRecommendation>> _generateSustainabilityOptions(
      BillOfMaterials bom) async {
    final recommendations = <AiRecommendation>[];

    // Sustainable materials
    recommendations.add(AiRecommendation(
      id: 'sustainable_materials_${bom.id}_${DateTime.now().millisecondsSinceEpoch}',
      bomId: bom.id,
      type: 'sustainable_materials',
      title: 'Sustainable Material Substitution',
      description: 'Replace materials with more sustainable alternatives',
      confidenceScore: 0.70,
      expectedImpact: 5.0,
      implementationComplexity: 'High',
      estimatedSavings: 0.0, // May increase costs but provide other benefits
      riskLevel: 'Medium',
      priority: 'Low',
      category: 'Sustainability',
      generatedAt: DateTime.now(),
      actionSteps: [
        'Research sustainable alternatives',
        'Evaluate performance characteristics',
        'Implement gradual substitution',
      ],
      affectedMaterials: bom.items.take(3).map((item) => item.itemId).toList(),
    ));

    return recommendations;
  }

  Future<List<AiRecommendation>> _generateRiskMitigations(
      BillOfMaterials bom) async {
    final recommendations = <AiRecommendation>[];

    // Supply chain diversification
    recommendations.add(AiRecommendation(
      id: 'supply_diversification_${bom.id}_${DateTime.now().millisecondsSinceEpoch}',
      bomId: bom.id,
      type: 'supply_diversification',
      title: 'Supply Chain Diversification',
      description: 'Diversify suppliers to reduce supply chain risk',
      confidenceScore: 0.88,
      expectedImpact: 20.0,
      implementationComplexity: 'High',
      estimatedSavings: bom.totalCost * 0.02, // Risk reduction value
      riskLevel: 'Low',
      priority: 'High',
      category: 'Risk Management',
      generatedAt: DateTime.now(),
      actionSteps: [
        'Identify critical materials',
        'Find alternative suppliers',
        'Establish backup supply agreements',
      ],
      affectedMaterials: bom.items.take(5).map((item) => item.itemId).toList(),
    ));

    return recommendations;
  }

  // Predictive analysis methods

  Future<Map<String, double>> _predictDemand(BillOfMaterials bom) async {
    final demandForecast = <String, double>{};

    for (final item in bom.items) {
      // Simulate demand prediction using historical patterns
      final baseQuantity = item.quantity;
      final seasonalFactor = 1.0 + (sin(DateTime.now().month * pi / 6) * 0.2);
      final trendFactor = 1.05; // 5% growth trend
      final randomFactor =
          0.9 + (Random().nextDouble() * 0.2); // ±10% variation

      demandForecast[item.itemId] =
          baseQuantity * seasonalFactor * trendFactor * randomFactor;
    }

    return demandForecast;
  }

  Future<Map<String, List<double>>> _predictCostTrends(
      BillOfMaterials bom) async {
    final costTrends = <String, List<double>>{};

    for (final item in bom.items) {
      // Simulate cost trend prediction
      final baseCost = item.costPerUnit;
      final trend = <double>[];

      for (int i = 0; i < 12; i++) {
        // 12 months forecast
        final inflationFactor = 1.0 + (0.03 / 12); // 3% annual inflation
        final volatilityFactor =
            0.95 + (Random().nextDouble() * 0.1); // ±5% volatility
        final monthCost = baseCost * pow(inflationFactor, i) * volatilityFactor;
        trend.add(monthCost);
      }

      costTrends[item.itemId] = trend;
    }

    return costTrends;
  }

  Future<Map<String, double>> _predictQuality(BillOfMaterials bom) async {
    final qualityPredictions = <String, double>{};

    for (final item in bom.items) {
      // Simulate quality prediction
      final baseQuality = 85.0; // Base quality score
      final supplierFactor = (item.supplierCode?.hashCode.abs() ?? 0) % 20 -
          10; // ±10 based on supplier
      final materialFactor =
          item.itemCode.hashCode.abs() % 10 - 5; // ±5 based on material

      qualityPredictions[item.itemId] =
          (baseQuality + supplierFactor + materialFactor).clamp(0.0, 100.0);
    }

    return qualityPredictions;
  }

  Future<Map<String, double>> _assessSupplierRisk(BillOfMaterials bom) async {
    final riskAssessment = <String, double>{};

    final suppliers = bom.items
        .where((item) => item.supplierCode != null)
        .map((item) => item.supplierCode!)
        .toSet();

    for (final supplier in suppliers) {
      // Simulate risk assessment
      final baseRisk = 0.3; // 30% base risk
      final reliabilityFactor =
          (supplier.hashCode.abs() % 40 - 20) / 100; // ±20%
      final riskScore = (baseRisk + reliabilityFactor).clamp(0.0, 1.0);

      riskAssessment[supplier] = riskScore;
    }

    return riskAssessment;
  }

  Future<Map<String, double>> _predictMaterialAvailability(
      BillOfMaterials bom) async {
    final availabilityForecast = <String, double>{};

    for (final item in bom.items) {
      // Simulate availability prediction
      final baseAvailability = 0.9; // 90% base availability
      final demandFactor = (item.quantity > 100)
          ? -0.1
          : 0.0; // High demand reduces availability
      final supplierFactor =
          ((item.supplierCode?.hashCode.abs() ?? 0) % 20 - 10) /
              100; // Supplier reliability

      availabilityForecast[item.itemId] =
          (baseAvailability + demandFactor + supplierFactor).clamp(0.0, 1.0);
    }

    return availabilityForecast;
  }

  Future<List<String>> _identifyOptimizationOpportunities(
      BillOfMaterials bom) async {
    final opportunities = <String>[];

    // Cost optimization opportunities
    if (bom.totalCost > 10000) {
      opportunities
          .add('High-value BOM suitable for cost optimization initiatives');
    }

    // Complexity reduction opportunities
    if (bom.items.length > 20) {
      opportunities.add('Complex BOM with potential for simplification');
    }

    // Supplier optimization opportunities
    final uniqueSuppliers = bom.items
        .where((item) => item.supplierCode != null)
        .map((item) => item.supplierCode!)
        .toSet()
        .length;

    if (uniqueSuppliers > 10) {
      opportunities
          .add('Multiple suppliers present - consolidation opportunity');
    }

    return opportunities;
  }

  Map<String, Map<String, double>> _generateConfidenceIntervals(
      BillOfMaterials bom) {
    final intervals = <String, Map<String, double>>{};

    for (final item in bom.items) {
      intervals[item.itemId] = {
        'lower': 0.8,
        'upper': 0.95,
        'mean': 0.875,
      };
    }

    return intervals;
  }

  Future<Map<String, dynamic>> _performScenarioAnalysis(
      BillOfMaterials bom) async {
    return {
      'best_case': {
        'cost_reduction': 25.0,
        'quality_improvement': 20.0,
        'efficiency_gain': 30.0,
      },
      'worst_case': {
        'cost_increase': 10.0,
        'quality_decline': 5.0,
        'efficiency_loss': 8.0,
      },
      'most_likely': {
        'cost_reduction': 12.0,
        'quality_improvement': 10.0,
        'efficiency_gain': 15.0,
      },
    };
  }

  double _calculateOverallOptimizationScore(List<BillOfMaterials> boms) {
    // Simplified optimization score calculation
    double totalScore = 0.0;

    for (final bom in boms) {
      double bomScore = 70.0; // Base score

      // Adjust based on complexity
      if (bom.items.length > 20) bomScore -= 10;
      if (bom.items.length < 5) bomScore += 10;

      // Adjust based on cost
      if (bom.totalCost > 50000) bomScore -= 5;
      if (bom.totalCost < 5000) bomScore += 5;

      totalScore += bomScore;
    }

    return boms.isNotEmpty ? totalScore / boms.length : 0.0;
  }

  List<String> _generateImplementationRoadmap(
      List<AiRecommendation> recommendations) {
    final roadmap = <String>[];

    // Sort by priority and complexity
    final sortedRecs = recommendations.toList()
      ..sort((a, b) {
        final priorityComparison = _getPriorityValue(b.priority)
            .compareTo(_getPriorityValue(a.priority));
        if (priorityComparison != 0) return priorityComparison;
        return _getComplexityValue(a.implementationComplexity)
            .compareTo(_getComplexityValue(b.implementationComplexity));
      });

    // Phase 1: High priority, low complexity
    final phase1 = sortedRecs
        .where((rec) =>
            rec.priority == 'High' && rec.implementationComplexity == 'Low')
        .take(3);
    if (phase1.isNotEmpty) {
      roadmap
          .add('Phase 1 (Weeks 1-4): ${phase1.map((r) => r.title).join(', ')}');
    }

    // Phase 2: High priority, medium complexity
    final phase2 = sortedRecs
        .where((rec) =>
            rec.priority == 'High' && rec.implementationComplexity == 'Medium')
        .take(3);
    if (phase2.isNotEmpty) {
      roadmap.add(
          'Phase 2 (Weeks 5-12): ${phase2.map((r) => r.title).join(', ')}');
    }

    // Phase 3: Medium priority or high complexity
    final phase3 = sortedRecs
        .where((rec) =>
            rec.priority == 'Medium' || rec.implementationComplexity == 'High')
        .take(3);
    if (phase3.isNotEmpty) {
      roadmap.add(
          'Phase 3 (Weeks 13-26): ${phase3.map((r) => r.title).join(', ')}');
    }

    return roadmap;
  }

  Map<String, double> _calculateExpectedOutcomes(
      List<AiRecommendation> recommendations) {
    return {
      'total_cost_savings': recommendations
          .map((r) => r.estimatedSavings)
          .fold(0.0, (sum, savings) => sum + savings),
      'average_impact': recommendations.isNotEmpty
          ? recommendations
                  .map((r) => r.expectedImpact)
                  .reduce((a, b) => a + b) /
              recommendations.length
          : 0.0,
      'implementation_time_weeks':
          recommendations.length * 2.0, // Estimate 2 weeks per recommendation
      'risk_score': recommendations.isNotEmpty
          ? recommendations
                  .map((r) => _getRiskValue(r.riskLevel))
                  .reduce((a, b) => a + b) /
              recommendations.length
          : 0.0,
    };
  }

  int _getPriorityValue(String priority) {
    switch (priority.toLowerCase()) {
      case 'critical':
        return 4;
      case 'high':
        return 3;
      case 'medium':
        return 2;
      case 'low':
        return 1;
      default:
        return 0;
    }
  }

  int _getComplexityValue(String complexity) {
    switch (complexity.toLowerCase()) {
      case 'low':
        return 1;
      case 'medium':
        return 2;
      case 'high':
        return 3;
      default:
        return 2;
    }
  }

  double _getRiskValue(String risk) {
    switch (risk.toLowerCase()) {
      case 'low':
        return 0.2;
      case 'medium':
        return 0.5;
      case 'high':
        return 0.8;
      default:
        return 0.5;
    }
  }
}

/// Provider for AI Optimization Service
final aiOptimizationServiceProvider = Provider<AiOptimizationService>((ref) {
  return AiOptimizationService(
    bomRepository: ref.watch(bomRepositoryProvider),
    inventoryRepository:
        ref.watch(inventory_provider.inventoryRepositoryProvider),
    supplierRepository: ref.watch(supplier_provider.supplierRepositoryProvider),
    logger: Logger(),
  );
});
